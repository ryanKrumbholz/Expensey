{"ast":null,"code":"'use strict';\n\nvar crypto = require('crypto');\n\nvar iterations = 10000;\n\nvar password = function (password) {\n  return {\n    hash: function (salt, callback) {\n      // Make salt optional\n      if (callback === undefined && salt instanceof Function) {\n        callback = salt;\n        salt = undefined;\n      }\n\n      if (!password) {\n        return callback('No password provided');\n      }\n\n      if (typeof salt === 'string') {\n        salt = new Buffer(salt, 'hex');\n      }\n\n      var calcHash = function () {\n        crypto.pbkdf2(password, salt, iterations, 64, 'sha1', function (err, key) {\n          if (err) return callback(err);\n          var res = 'pbkdf2$' + iterations + '$' + key.toString('hex') + '$' + salt.toString('hex');\n          callback(null, res);\n        });\n      };\n\n      if (!salt) {\n        crypto.randomBytes(64, function (err, gensalt) {\n          if (err) return callback(err);\n          salt = gensalt;\n          calcHash();\n        });\n      } else {\n        calcHash();\n      }\n    },\n    verifyAgainst: function (hashedPassword, callback) {\n      if (!hashedPassword || !password) return callback(null, false);\n      var key = hashedPassword.split('$');\n      if (key.length !== 4 || !key[2] || !key[3]) return callback('Hash not formatted correctly');\n      if (key[0] !== 'pbkdf2' || key[1] !== iterations.toString()) return callback('Wrong algorithm and/or iterations');\n      this.hash(key[3], function (error, newHash) {\n        if (error) return callback(error);\n        callback(null, newHash === hashedPassword);\n      });\n    }\n  };\n};\n\nmodule.exports = password;","map":{"version":3,"sources":["/Users/ryankrumbholz/OneDrive/development/expensey/expensey-client /client/node_modules/password-hash-and-salt/lib/hashsalt.js"],"names":["crypto","require","iterations","password","hash","salt","callback","undefined","Function","Buffer","calcHash","pbkdf2","err","key","res","toString","randomBytes","gensalt","verifyAgainst","hashedPassword","split","length","error","newHash","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AAEA,IAAIC,UAAU,GAAG,KAAjB;;AACA,IAAIC,QAAQ,GAAG,UAASA,QAAT,EAAmB;AACjC,SAAO;AACNC,IAAAA,IAAI,EAAE,UAASC,IAAT,EAAeC,QAAf,EAAyB;AAC9B;AACA,UAAGA,QAAQ,KAAKC,SAAb,IAA0BF,IAAI,YAAYG,QAA7C,EAAuD;AACtDF,QAAAA,QAAQ,GAAGD,IAAX;AACAA,QAAAA,IAAI,GAAGE,SAAP;AACA;;AAED,UAAG,CAACJ,QAAJ,EAAc;AACb,eAAOG,QAAQ,CAAC,sBAAD,CAAf;AACA;;AAED,UAAG,OAAOD,IAAP,KAAgB,QAAnB,EAA6B;AAC5BA,QAAAA,IAAI,GAAG,IAAII,MAAJ,CAAWJ,IAAX,EAAiB,KAAjB,CAAP;AACA;;AAED,UAAIK,QAAQ,GAAG,YAAW;AACzBV,QAAAA,MAAM,CAACW,MAAP,CAAcR,QAAd,EAAwBE,IAAxB,EAA8BH,UAA9B,EAA0C,EAA1C,EAA8C,MAA9C,EAAsD,UAASU,GAAT,EAAcC,GAAd,EAAmB;AACxE,cAAGD,GAAH,EACC,OAAON,QAAQ,CAACM,GAAD,CAAf;AACD,cAAIE,GAAG,GAAG,YAAYZ,UAAZ,GACP,GADO,GACDW,GAAG,CAACE,QAAJ,CAAa,KAAb,CADC,GAEP,GAFO,GAEDV,IAAI,CAACU,QAAL,CAAc,KAAd,CAFT;AAGAT,UAAAA,QAAQ,CAAC,IAAD,EAAOQ,GAAP,CAAR;AACA,SAPD;AAQA,OATD;;AAWA,UAAG,CAACT,IAAJ,EAAU;AACTL,QAAAA,MAAM,CAACgB,WAAP,CAAmB,EAAnB,EAAuB,UAASJ,GAAT,EAAcK,OAAd,EAAuB;AAC7C,cAAGL,GAAH,EACC,OAAON,QAAQ,CAACM,GAAD,CAAf;AACDP,UAAAA,IAAI,GAAGY,OAAP;AACAP,UAAAA,QAAQ;AACR,SALD;AAMA,OAPD,MAOO;AACNA,QAAAA,QAAQ;AACR;AACD,KArCK;AAuCNQ,IAAAA,aAAa,EAAE,UAASC,cAAT,EAAyBb,QAAzB,EAAmC;AACjD,UAAG,CAACa,cAAD,IAAmB,CAAChB,QAAvB,EACC,OAAOG,QAAQ,CAAC,IAAD,EAAO,KAAP,CAAf;AAED,UAAIO,GAAG,GAAGM,cAAc,CAACC,KAAf,CAAqB,GAArB,CAAV;AACA,UAAGP,GAAG,CAACQ,MAAJ,KAAe,CAAf,IAAoB,CAACR,GAAG,CAAC,CAAD,CAAxB,IAA+B,CAACA,GAAG,CAAC,CAAD,CAAtC,EACC,OAAOP,QAAQ,CAAC,8BAAD,CAAf;AAED,UAAGO,GAAG,CAAC,CAAD,CAAH,KAAW,QAAX,IAAuBA,GAAG,CAAC,CAAD,CAAH,KAAWX,UAAU,CAACa,QAAX,EAArC,EACC,OAAOT,QAAQ,CAAC,mCAAD,CAAf;AAED,WAAKF,IAAL,CAAUS,GAAG,CAAC,CAAD,CAAb,EAAkB,UAASS,KAAT,EAAgBC,OAAhB,EAAyB;AAC1C,YAAGD,KAAH,EACC,OAAOhB,QAAQ,CAACgB,KAAD,CAAf;AACDhB,QAAAA,QAAQ,CAAC,IAAD,EAAOiB,OAAO,KAAKJ,cAAnB,CAAR;AACA,OAJD;AAKA;AAvDK,GAAP;AAyDA,CA1DD;;AA6DAK,MAAM,CAACC,OAAP,GAAiBtB,QAAjB","sourcesContent":["'use strict';\n\nvar crypto = require('crypto');\n\nvar iterations = 10000;\nvar password = function(password) {\n\treturn {\n\t\thash: function(salt, callback) {\n\t\t\t// Make salt optional\n\t\t\tif(callback === undefined && salt instanceof Function) {\n\t\t\t\tcallback = salt;\n\t\t\t\tsalt = undefined;\n\t\t\t}\n\n\t\t\tif(!password) {\n\t\t\t\treturn callback('No password provided')\n\t\t\t}\n\n\t\t\tif(typeof salt === 'string') {\n\t\t\t\tsalt = new Buffer(salt, 'hex');\n\t\t\t}\n\n\t\t\tvar calcHash = function() {\n\t\t\t\tcrypto.pbkdf2(password, salt, iterations, 64, 'sha1', function(err, key) {\n\t\t\t\t\tif(err)\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\tvar res = 'pbkdf2$' + iterations + \n\t\t\t\t\t\t\t\t'$' + key.toString('hex') + \n\t\t\t\t\t\t\t\t'$' + salt.toString('hex');\n\t\t\t\t\tcallback(null, res);\n\t\t\t\t})\t\t\n\t\t\t};\n\n\t\t\tif(!salt) {\n\t\t\t\tcrypto.randomBytes(64, function(err, gensalt) {\n\t\t\t\t\tif(err)\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\tsalt = gensalt;\n\t\t\t\t\tcalcHash();\n\t\t\t\t});\t\t\n\t\t\t} else {\n\t\t\t\tcalcHash();\n\t\t\t}\t\t\t\n\t\t},\n\n\t\tverifyAgainst: function(hashedPassword, callback) {\n\t\t\tif(!hashedPassword || !password)\n\t\t\t\treturn callback(null, false);\n\n\t\t\tvar key = hashedPassword.split('$');\n\t\t\tif(key.length !== 4 || !key[2] || !key[3])\n\t\t\t\treturn callback('Hash not formatted correctly');\n\n\t\t\tif(key[0] !== 'pbkdf2' || key[1] !== iterations.toString())\n\t\t\t\treturn callback('Wrong algorithm and/or iterations');\n\n\t\t\tthis.hash(key[3], function(error, newHash) {\n\t\t\t\tif(error)\n\t\t\t\t\treturn callback(error);\n\t\t\t\tcallback(null, newHash === hashedPassword);\t\t\t\t\n\t\t\t});\t\n\t\t}\n\t};\n}\n\n\nmodule.exports = password;\n"]},"metadata":{},"sourceType":"script"}