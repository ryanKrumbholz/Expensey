{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst isResumableError = require('./error').isResumableError;\n\nconst MongoError = require('./core').MongoError;\n\nconst Cursor = require('./cursor');\n\nconst relayEvents = require('./core/utils').relayEvents;\n\nconst maxWireVersion = require('./core/utils').maxWireVersion;\n\nconst AggregateOperation = require('./operations/aggregate');\n\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(CHANGE_STREAM_OPTIONS);\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\n/**\n * @typedef ResumeToken\n * @description Represents the logical starting point for a new or resuming {@link ChangeStream} on the server.\n * @see https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token\n */\n\n/**\n * @typedef OperationTime\n * @description Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}\n * @see https://docs.mongodb.com/manual/reference/method/db.runCommand/#response\n */\n\n/**\n * @typedef ChangeStreamOptions\n * @description Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\n * @property {string} [fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\n * @property {number} [maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query.\n * @property {ResumeToken} [resumeAfter] Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}.\n * @property {ResumeToken} [startAfter] Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}.\n * @property {OperationTime} [startAtOperationTime] Will start the changeStream after the specified operationTime.\n * @property {number} [batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {object} [collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {ReadPreference} [readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\n */\n\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @class ChangeStream\n * @since 3.0.0\n * @param {(MongoClient|Db|Collection)} parent The parent object that created this change stream\n * @param {Array} pipeline An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n * @param {ChangeStreamOptions} [options] Optional settings\n * @fires ChangeStream#close\n * @fires ChangeStream#change\n * @fires ChangeStream#end\n * @fires ChangeStream#error\n * @fires ChangeStream#resumeTokenChanged\n * @return {ChangeStream} a ChangeStream instance.\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(parent, pipeline, options) {\n    super();\n\n    const Collection = require('./collection');\n\n    const Db = require('./db');\n\n    const MongoClient = require('./mongo_client');\n\n    this.pipeline = pipeline || [];\n    this.options = options || {};\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n\n    if (parent instanceof Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n      this.topology = parent.s.db.serverConfig;\n    } else if (parent instanceof Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n      this.topology = parent.serverConfig;\n    } else if (parent instanceof MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n      this.topology = parent.topology;\n    } else {\n      throw new TypeError('parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient');\n    }\n\n    this.promiseLibrary = parent.s.promiseLibrary;\n\n    if (!this.options.readPreference && parent.s.readPreference) {\n      this.options.readPreference = parent.s.readPreference;\n    } // Create contained Change Stream cursor\n\n\n    this.cursor = createChangeStreamCursor(this, options); // Listen for any `change` listeners being added to ChangeStream\n\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        this.cursor.on('data', change => processNewChange({\n          changeStream: this,\n          change,\n          eventEmitter: true\n        }));\n      }\n    }); // Listen for all `change` listeners being removed from ChangeStream\n\n    this.on('removeListener', eventName => {\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        this.cursor.removeAllListeners('data');\n      }\n    });\n  }\n  /**\n   * @property {ResumeToken} resumeToken\n   * The cached resume token that will be used to resume\n   * after the most recently returned change.\n   */\n\n\n  get resumeToken() {\n    return this.cursor.resumeToken;\n  }\n  /**\n   * Check if there is any document still available in the Change Stream\n   * @function ChangeStream.prototype.hasNext\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @return {Promise} returns Promise if no callback passed\n   */\n\n\n  hasNext(callback) {\n    return this.cursor.hasNext(callback);\n  }\n  /**\n   * Get the next available document from the Change Stream, returns null if no more documents are available.\n   * @function ChangeStream.prototype.next\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @return {Promise} returns Promise if no callback passed\n   */\n\n\n  next(callback) {\n    var self = this;\n\n    if (this.isClosed()) {\n      if (callback) return callback(new Error('Change Stream is not open.'), null);\n      return self.promiseLibrary.reject(new Error('Change Stream is not open.'));\n    }\n\n    return this.cursor.next().then(change => processNewChange({\n      changeStream: self,\n      change,\n      callback\n    })).catch(error => processNewChange({\n      changeStream: self,\n      error,\n      callback\n    }));\n  }\n  /**\n   * Is the cursor closed\n   * @method ChangeStream.prototype.isClosed\n   * @return {boolean}\n   */\n\n\n  isClosed() {\n    if (this.cursor) {\n      return this.cursor.isClosed();\n    }\n\n    return true;\n  }\n  /**\n   * Close the Change Stream\n   * @method ChangeStream.prototype.close\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @return {Promise} returns Promise if no callback passed\n   */\n\n\n  close(callback) {\n    if (!this.cursor) {\n      if (callback) return callback();\n      return this.promiseLibrary.resolve();\n    } // Tidy up the existing cursor\n\n\n    const cursor = this.cursor;\n\n    if (callback) {\n      return cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        delete this.cursor;\n        return callback(err);\n      });\n    }\n\n    const PromiseCtor = this.promiseLibrary || Promise;\n    return new PromiseCtor((resolve, reject) => {\n      cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        delete this.cursor;\n        if (err) return reject(err);\n        resolve();\n      });\n    });\n  }\n  /**\n   * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\n   * @method\n   * @param {Writable} destination The destination for writing data\n   * @param {object} [options] {@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options}\n   * @return {null}\n   */\n\n\n  pipe(destination, options) {\n    if (!this.pipeDestinations) {\n      this.pipeDestinations = [];\n    }\n\n    this.pipeDestinations.push(destination);\n    return this.cursor.pipe(destination, options);\n  }\n  /**\n   * This method will remove the hooks set up for a previous pipe() call.\n   * @param {Writable} [destination] The destination for writing data\n   * @return {null}\n   */\n\n\n  unpipe(destination) {\n    if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {\n      this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);\n    }\n\n    return this.cursor.unpipe(destination);\n  }\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   * @method\n   * @param {object} [options] Optional settings.\n   * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.\n   * @return {Cursor}\n   */\n\n\n  stream(options) {\n    this.streamOptions = options;\n    return this.cursor.stream(options);\n  }\n  /**\n   * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\n   * @return {null}\n   */\n\n\n  pause() {\n    return this.cursor.pause();\n  }\n  /**\n   * This method will cause the readable stream to resume emitting data events.\n   * @return {null}\n   */\n\n\n  resume() {\n    return this.cursor.resume();\n  }\n\n}\n\nclass ChangeStreamCursor extends Cursor {\n  constructor(topology, operation, options) {\n    super(topology, operation, options);\n    options = options || {};\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit('resumeTokenChanged', token);\n  }\n\n  get resumeToken() {\n    return this._resumeToken;\n  }\n\n  get resumeOptions() {\n    const result = {};\n\n    for (const optionName of CURSOR_OPTIONS) {\n      if (this.options[optionName]) result[optionName] = this.options[optionName];\n    }\n\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key => delete result[key]);\n\n      if (this.resumeToken) {\n        result.resumeAfter = this.resumeToken;\n      } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n\n    return result;\n  }\n\n  _initializeCursor(callback) {\n    super._initializeCursor((err, result) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      const response = result.documents[0];\n\n      if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      const cursor = response.cursor;\n\n      if (cursor.postBatchResumeToken) {\n        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n        if (cursor.firstBatch.length === 0) {\n          this.resumeToken = cursor.postBatchResumeToken;\n        }\n      }\n\n      this.emit('response');\n      callback(err, result);\n    });\n  }\n\n  _getMore(callback) {\n    super._getMore((err, response) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      const cursor = response.cursor;\n\n      if (cursor.postBatchResumeToken) {\n        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n        if (cursor.nextBatch.length === 0) {\n          this.resumeToken = cursor.postBatchResumeToken;\n        }\n      }\n\n      this.emit('response');\n      callback(err, response);\n    });\n  }\n\n}\n/**\n * @event ChangeStreamCursor#response\n * internal event DO NOT USE\n * @ignore\n */\n// Create a new change stream cursor based on self's configuration\n\n\nfunction createChangeStreamCursor(self, options) {\n  const changeStreamStageOptions = {\n    fullDocument: options.fullDocument || 'default'\n  };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n\n  if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n\n  const pipeline = [{\n    $changeStream: changeStreamStageOptions\n  }].concat(self.pipeline);\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n  const changeStreamCursor = new ChangeStreamCursor(self.topology, new AggregateOperation(self.parent, pipeline, options), cursorOptions);\n  relayEvents(changeStreamCursor, self, ['resumeTokenChanged', 'end', 'close']);\n  /**\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\n   * then be passed as soon as it is available.\n   *\n   * @event ChangeStream#change\n   * @type {object}\n   */\n\n  if (self.listenerCount('change') > 0) {\n    changeStreamCursor.on('data', function (change) {\n      processNewChange({\n        changeStream: self,\n        change,\n        eventEmitter: true\n      });\n    });\n  }\n  /**\n   * Change stream close event\n   *\n   * @event ChangeStream#close\n   * @type {null}\n   */\n\n  /**\n   * Change stream end event\n   *\n   * @event ChangeStream#end\n   * @type {null}\n   */\n\n  /**\n   * Emitted each time the change stream stores a new resume token.\n   *\n   * @event ChangeStream#resumeTokenChanged\n   * @type {ResumeToken}\n   */\n\n  /**\n   * Fired when the stream encounters an error.\n   *\n   * @event ChangeStream#error\n   * @type {Error}\n   */\n\n\n  changeStreamCursor.on('error', function (error) {\n    processNewChange({\n      changeStream: self,\n      error,\n      eventEmitter: true\n    });\n  });\n\n  if (self.pipeDestinations) {\n    const cursorStream = changeStreamCursor.stream(self.streamOptions);\n\n    for (let pipeDestination in self.pipeDestinations) {\n      cursorStream.pipe(pipeDestination);\n    }\n  }\n\n  return changeStreamCursor;\n}\n\nfunction applyKnownOptions(target, source, optionNames) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n  return target;\n} // This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\n\n\nconst SELECTION_TIMEOUT = 30000;\n\nfunction waitForTopologyConnected(topology, options, callback) {\n  setTimeout(() => {\n    if (options && options.start == null) options.start = process.hrtime();\n    const start = options.start || process.hrtime();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    const readPreference = options.readPreference;\n    if (topology.isConnected({\n      readPreference\n    })) return callback(null, null);\n    const hrElapsed = process.hrtime(start);\n    const elapsed = (hrElapsed[0] * 1e9 + hrElapsed[1]) / 1e6;\n    if (elapsed > timeout) return callback(new MongoError('Timed out waiting for connection'));\n    waitForTopologyConnected(topology, options, callback);\n  }, 3000); // this is an arbitrary wait time to allow SDAM to transition\n} // Handle new change events. This method brings together the routes from the callback, event emitter, and promise ways of using ChangeStream.\n\n\nfunction processNewChange(args) {\n  const changeStream = args.changeStream;\n  const error = args.error;\n  const change = args.change;\n  const callback = args.callback;\n  const eventEmitter = args.eventEmitter || false; // If the changeStream is closed, then it should not process a change.\n\n  if (changeStream.isClosed()) {\n    // We do not error in the eventEmitter case.\n    if (eventEmitter) {\n      return;\n    }\n\n    const error = new MongoError('ChangeStream is closed');\n    return typeof callback === 'function' ? callback(error, null) : changeStream.promiseLibrary.reject(error);\n  }\n\n  const cursor = changeStream.cursor;\n  const topology = changeStream.topology;\n  const options = changeStream.cursor.options;\n\n  if (error) {\n    if (isResumableError(error) && !changeStream.attemptingResume) {\n      changeStream.attemptingResume = true; // stop listening to all events from old cursor\n\n      ['data', 'close', 'end', 'error'].forEach(event => changeStream.cursor.removeAllListeners(event)); // close internal cursor, ignore errors\n\n      changeStream.cursor.close(); // attempt recreating the cursor\n\n      if (eventEmitter) {\n        waitForTopologyConnected(topology, {\n          readPreference: options.readPreference\n        }, err => {\n          if (err) {\n            changeStream.emit('error', err);\n            changeStream.emit('close');\n            return;\n          }\n\n          changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n        });\n        return;\n      }\n\n      if (callback) {\n        waitForTopologyConnected(topology, {\n          readPreference: options.readPreference\n        }, err => {\n          if (err) return callback(err, null);\n          changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n          changeStream.next(callback);\n        });\n        return;\n      }\n\n      return new Promise((resolve, reject) => {\n        waitForTopologyConnected(topology, {\n          readPreference: options.readPreference\n        }, err => {\n          if (err) return reject(err);\n          resolve();\n        });\n      }).then(() => changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions)).then(() => changeStream.next());\n    }\n\n    if (eventEmitter) return changeStream.emit('error', error);\n    if (typeof callback === 'function') return callback(error, null);\n    return changeStream.promiseLibrary.reject(error);\n  }\n\n  changeStream.attemptingResume = false;\n\n  if (change && !change._id) {\n    const noResumeTokenError = new Error('A change stream document has been received that lacks a resume token (_id).');\n    if (eventEmitter) return changeStream.emit('error', noResumeTokenError);\n    if (typeof callback === 'function') return callback(noResumeTokenError, null);\n    return changeStream.promiseLibrary.reject(noResumeTokenError);\n  } // cache the resume token\n\n\n  if (cursor.bufferedCount() === 0 && cursor.cursorState.postBatchResumeToken) {\n    cursor.resumeToken = cursor.cursorState.postBatchResumeToken;\n  } else {\n    cursor.resumeToken = change._id;\n  } // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n\n\n  changeStream.options.startAtOperationTime = undefined; // Return the change\n\n  if (eventEmitter) return changeStream.emit('change', change);\n  if (typeof callback === 'function') return callback(error, change);\n  return changeStream.promiseLibrary.resolve(change);\n}\n/**\n * The callback format for results\n * @callback ChangeStream~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {(object|null)} result The result object if the command was executed successfully.\n */\n\n\nmodule.exports = ChangeStream;","map":{"version":3,"sources":["/Users/ryankrumbholz/OneDrive/development/expensey/expensey-client/client/node_modules/mongodb/lib/change_stream.js"],"names":["EventEmitter","require","isResumableError","MongoError","Cursor","relayEvents","maxWireVersion","AggregateOperation","CHANGE_STREAM_OPTIONS","CURSOR_OPTIONS","concat","CHANGE_DOMAIN_TYPES","COLLECTION","Symbol","DATABASE","CLUSTER","ChangeStream","constructor","parent","pipeline","options","Collection","Db","MongoClient","namespace","s","type","topology","db","serverConfig","TypeError","promiseLibrary","readPreference","cursor","createChangeStreamCursor","on","eventName","listenerCount","change","processNewChange","changeStream","eventEmitter","removeAllListeners","resumeToken","hasNext","callback","next","self","isClosed","Error","reject","then","catch","error","close","resolve","err","forEach","event","PromiseCtor","Promise","pipe","destination","pipeDestinations","push","unpipe","indexOf","splice","stream","streamOptions","pause","resume","ChangeStreamCursor","operation","_resumeToken","startAtOperationTime","startAfter","resumeAfter","token","emit","resumeOptions","result","optionName","key","server","_initializeCursor","response","documents","operationTime","postBatchResumeToken","cursorState","firstBatch","length","_getMore","nextBatch","changeStreamStageOptions","fullDocument","applyKnownOptions","allChangesForCluster","$changeStream","cursorOptions","changeStreamCursor","cursorStream","pipeDestination","target","source","optionNames","name","SELECTION_TIMEOUT","waitForTopologyConnected","setTimeout","start","process","hrtime","timeout","isConnected","hrElapsed","elapsed","args","attemptingResume","_id","noResumeTokenError","bufferedCount","undefined","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst isResumableError = require('./error').isResumableError;\nconst MongoError = require('./core').MongoError;\nconst Cursor = require('./cursor');\nconst relayEvents = require('./core/utils').relayEvents;\nconst maxWireVersion = require('./core/utils').maxWireVersion;\nconst AggregateOperation = require('./operations/aggregate');\n\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(\n  CHANGE_STREAM_OPTIONS\n);\n\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\n\n/**\n * @typedef ResumeToken\n * @description Represents the logical starting point for a new or resuming {@link ChangeStream} on the server.\n * @see https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token\n */\n\n/**\n * @typedef OperationTime\n * @description Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}\n * @see https://docs.mongodb.com/manual/reference/method/db.runCommand/#response\n */\n\n/**\n * @typedef ChangeStreamOptions\n * @description Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\n * @property {string} [fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\n * @property {number} [maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query.\n * @property {ResumeToken} [resumeAfter] Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}.\n * @property {ResumeToken} [startAfter] Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}.\n * @property {OperationTime} [startAtOperationTime] Will start the changeStream after the specified operationTime.\n * @property {number} [batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {object} [collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {ReadPreference} [readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\n */\n\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @class ChangeStream\n * @since 3.0.0\n * @param {(MongoClient|Db|Collection)} parent The parent object that created this change stream\n * @param {Array} pipeline An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n * @param {ChangeStreamOptions} [options] Optional settings\n * @fires ChangeStream#close\n * @fires ChangeStream#change\n * @fires ChangeStream#end\n * @fires ChangeStream#error\n * @fires ChangeStream#resumeTokenChanged\n * @return {ChangeStream} a ChangeStream instance.\n */\nclass ChangeStream extends EventEmitter {\n  constructor(parent, pipeline, options) {\n    super();\n    const Collection = require('./collection');\n    const Db = require('./db');\n    const MongoClient = require('./mongo_client');\n\n    this.pipeline = pipeline || [];\n    this.options = options || {};\n\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n    if (parent instanceof Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n      this.topology = parent.s.db.serverConfig;\n    } else if (parent instanceof Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n      this.topology = parent.serverConfig;\n    } else if (parent instanceof MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n      this.topology = parent.topology;\n    } else {\n      throw new TypeError(\n        'parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient'\n      );\n    }\n\n    this.promiseLibrary = parent.s.promiseLibrary;\n    if (!this.options.readPreference && parent.s.readPreference) {\n      this.options.readPreference = parent.s.readPreference;\n    }\n\n    // Create contained Change Stream cursor\n    this.cursor = createChangeStreamCursor(this, options);\n\n    // Listen for any `change` listeners being added to ChangeStream\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        this.cursor.on('data', change =>\n          processNewChange({ changeStream: this, change, eventEmitter: true })\n        );\n      }\n    });\n\n    // Listen for all `change` listeners being removed from ChangeStream\n    this.on('removeListener', eventName => {\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        this.cursor.removeAllListeners('data');\n      }\n    });\n  }\n\n  /**\n   * @property {ResumeToken} resumeToken\n   * The cached resume token that will be used to resume\n   * after the most recently returned change.\n   */\n  get resumeToken() {\n    return this.cursor.resumeToken;\n  }\n\n  /**\n   * Check if there is any document still available in the Change Stream\n   * @function ChangeStream.prototype.hasNext\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @return {Promise} returns Promise if no callback passed\n   */\n  hasNext(callback) {\n    return this.cursor.hasNext(callback);\n  }\n\n  /**\n   * Get the next available document from the Change Stream, returns null if no more documents are available.\n   * @function ChangeStream.prototype.next\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @return {Promise} returns Promise if no callback passed\n   */\n  next(callback) {\n    var self = this;\n    if (this.isClosed()) {\n      if (callback) return callback(new Error('Change Stream is not open.'), null);\n      return self.promiseLibrary.reject(new Error('Change Stream is not open.'));\n    }\n\n    return this.cursor\n      .next()\n      .then(change => processNewChange({ changeStream: self, change, callback }))\n      .catch(error => processNewChange({ changeStream: self, error, callback }));\n  }\n\n  /**\n   * Is the cursor closed\n   * @method ChangeStream.prototype.isClosed\n   * @return {boolean}\n   */\n  isClosed() {\n    if (this.cursor) {\n      return this.cursor.isClosed();\n    }\n    return true;\n  }\n\n  /**\n   * Close the Change Stream\n   * @method ChangeStream.prototype.close\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @return {Promise} returns Promise if no callback passed\n   */\n  close(callback) {\n    if (!this.cursor) {\n      if (callback) return callback();\n      return this.promiseLibrary.resolve();\n    }\n\n    // Tidy up the existing cursor\n    const cursor = this.cursor;\n\n    if (callback) {\n      return cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        delete this.cursor;\n\n        return callback(err);\n      });\n    }\n\n    const PromiseCtor = this.promiseLibrary || Promise;\n    return new PromiseCtor((resolve, reject) => {\n      cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        delete this.cursor;\n\n        if (err) return reject(err);\n        resolve();\n      });\n    });\n  }\n\n  /**\n   * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\n   * @method\n   * @param {Writable} destination The destination for writing data\n   * @param {object} [options] {@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options}\n   * @return {null}\n   */\n  pipe(destination, options) {\n    if (!this.pipeDestinations) {\n      this.pipeDestinations = [];\n    }\n    this.pipeDestinations.push(destination);\n    return this.cursor.pipe(destination, options);\n  }\n\n  /**\n   * This method will remove the hooks set up for a previous pipe() call.\n   * @param {Writable} [destination] The destination for writing data\n   * @return {null}\n   */\n  unpipe(destination) {\n    if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {\n      this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);\n    }\n    return this.cursor.unpipe(destination);\n  }\n\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   * @method\n   * @param {object} [options] Optional settings.\n   * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.\n   * @return {Cursor}\n   */\n  stream(options) {\n    this.streamOptions = options;\n    return this.cursor.stream(options);\n  }\n\n  /**\n   * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\n   * @return {null}\n   */\n  pause() {\n    return this.cursor.pause();\n  }\n\n  /**\n   * This method will cause the readable stream to resume emitting data events.\n   * @return {null}\n   */\n  resume() {\n    return this.cursor.resume();\n  }\n}\n\nclass ChangeStreamCursor extends Cursor {\n  constructor(topology, operation, options) {\n    super(topology, operation, options);\n\n    options = options || {};\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit('resumeTokenChanged', token);\n  }\n\n  get resumeToken() {\n    return this._resumeToken;\n  }\n\n  get resumeOptions() {\n    const result = {};\n    for (const optionName of CURSOR_OPTIONS) {\n      if (this.options[optionName]) result[optionName] = this.options[optionName];\n    }\n\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key => delete result[key]);\n\n      if (this.resumeToken) {\n        result.resumeAfter = this.resumeToken;\n      } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n\n    return result;\n  }\n\n  _initializeCursor(callback) {\n    super._initializeCursor((err, result) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      const response = result.documents[0];\n\n      if (\n        this.startAtOperationTime == null &&\n        this.resumeAfter == null &&\n        this.startAfter == null &&\n        maxWireVersion(this.server) >= 7\n      ) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      const cursor = response.cursor;\n      if (cursor.postBatchResumeToken) {\n        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n        if (cursor.firstBatch.length === 0) {\n          this.resumeToken = cursor.postBatchResumeToken;\n        }\n      }\n\n      this.emit('response');\n      callback(err, result);\n    });\n  }\n\n  _getMore(callback) {\n    super._getMore((err, response) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      const cursor = response.cursor;\n      if (cursor.postBatchResumeToken) {\n        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n        if (cursor.nextBatch.length === 0) {\n          this.resumeToken = cursor.postBatchResumeToken;\n        }\n      }\n\n      this.emit('response');\n      callback(err, response);\n    });\n  }\n}\n\n/**\n * @event ChangeStreamCursor#response\n * internal event DO NOT USE\n * @ignore\n */\n\n// Create a new change stream cursor based on self's configuration\nfunction createChangeStreamCursor(self, options) {\n  const changeStreamStageOptions = { fullDocument: options.fullDocument || 'default' };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n  if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n\n  const pipeline = [{ $changeStream: changeStreamStageOptions }].concat(self.pipeline);\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n  const changeStreamCursor = new ChangeStreamCursor(\n    self.topology,\n    new AggregateOperation(self.parent, pipeline, options),\n    cursorOptions\n  );\n\n  relayEvents(changeStreamCursor, self, ['resumeTokenChanged', 'end', 'close']);\n\n  /**\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\n   * then be passed as soon as it is available.\n   *\n   * @event ChangeStream#change\n   * @type {object}\n   */\n  if (self.listenerCount('change') > 0) {\n    changeStreamCursor.on('data', function(change) {\n      processNewChange({ changeStream: self, change, eventEmitter: true });\n    });\n  }\n\n  /**\n   * Change stream close event\n   *\n   * @event ChangeStream#close\n   * @type {null}\n   */\n\n  /**\n   * Change stream end event\n   *\n   * @event ChangeStream#end\n   * @type {null}\n   */\n\n  /**\n   * Emitted each time the change stream stores a new resume token.\n   *\n   * @event ChangeStream#resumeTokenChanged\n   * @type {ResumeToken}\n   */\n\n  /**\n   * Fired when the stream encounters an error.\n   *\n   * @event ChangeStream#error\n   * @type {Error}\n   */\n  changeStreamCursor.on('error', function(error) {\n    processNewChange({ changeStream: self, error, eventEmitter: true });\n  });\n\n  if (self.pipeDestinations) {\n    const cursorStream = changeStreamCursor.stream(self.streamOptions);\n    for (let pipeDestination in self.pipeDestinations) {\n      cursorStream.pipe(pipeDestination);\n    }\n  }\n\n  return changeStreamCursor;\n}\n\nfunction applyKnownOptions(target, source, optionNames) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n\n  return target;\n}\n\n// This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\nconst SELECTION_TIMEOUT = 30000;\nfunction waitForTopologyConnected(topology, options, callback) {\n  setTimeout(() => {\n    if (options && options.start == null) options.start = process.hrtime();\n    const start = options.start || process.hrtime();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    const readPreference = options.readPreference;\n\n    if (topology.isConnected({ readPreference })) return callback(null, null);\n    const hrElapsed = process.hrtime(start);\n    const elapsed = (hrElapsed[0] * 1e9 + hrElapsed[1]) / 1e6;\n    if (elapsed > timeout) return callback(new MongoError('Timed out waiting for connection'));\n    waitForTopologyConnected(topology, options, callback);\n  }, 3000); // this is an arbitrary wait time to allow SDAM to transition\n}\n\n// Handle new change events. This method brings together the routes from the callback, event emitter, and promise ways of using ChangeStream.\nfunction processNewChange(args) {\n  const changeStream = args.changeStream;\n  const error = args.error;\n  const change = args.change;\n  const callback = args.callback;\n  const eventEmitter = args.eventEmitter || false;\n\n  // If the changeStream is closed, then it should not process a change.\n  if (changeStream.isClosed()) {\n    // We do not error in the eventEmitter case.\n    if (eventEmitter) {\n      return;\n    }\n\n    const error = new MongoError('ChangeStream is closed');\n    return typeof callback === 'function'\n      ? callback(error, null)\n      : changeStream.promiseLibrary.reject(error);\n  }\n\n  const cursor = changeStream.cursor;\n  const topology = changeStream.topology;\n  const options = changeStream.cursor.options;\n\n  if (error) {\n    if (isResumableError(error) && !changeStream.attemptingResume) {\n      changeStream.attemptingResume = true;\n\n      // stop listening to all events from old cursor\n      ['data', 'close', 'end', 'error'].forEach(event =>\n        changeStream.cursor.removeAllListeners(event)\n      );\n\n      // close internal cursor, ignore errors\n      changeStream.cursor.close();\n\n      // attempt recreating the cursor\n      if (eventEmitter) {\n        waitForTopologyConnected(topology, { readPreference: options.readPreference }, err => {\n          if (err) {\n            changeStream.emit('error', err);\n            changeStream.emit('close');\n            return;\n          }\n          changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n        });\n\n        return;\n      }\n\n      if (callback) {\n        waitForTopologyConnected(topology, { readPreference: options.readPreference }, err => {\n          if (err) return callback(err, null);\n\n          changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n          changeStream.next(callback);\n        });\n\n        return;\n      }\n\n      return new Promise((resolve, reject) => {\n        waitForTopologyConnected(topology, { readPreference: options.readPreference }, err => {\n          if (err) return reject(err);\n          resolve();\n        });\n      })\n        .then(\n          () => (changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions))\n        )\n        .then(() => changeStream.next());\n    }\n\n    if (eventEmitter) return changeStream.emit('error', error);\n    if (typeof callback === 'function') return callback(error, null);\n    return changeStream.promiseLibrary.reject(error);\n  }\n\n  changeStream.attemptingResume = false;\n\n  if (change && !change._id) {\n    const noResumeTokenError = new Error(\n      'A change stream document has been received that lacks a resume token (_id).'\n    );\n\n    if (eventEmitter) return changeStream.emit('error', noResumeTokenError);\n    if (typeof callback === 'function') return callback(noResumeTokenError, null);\n    return changeStream.promiseLibrary.reject(noResumeTokenError);\n  }\n\n  // cache the resume token\n  if (cursor.bufferedCount() === 0 && cursor.cursorState.postBatchResumeToken) {\n    cursor.resumeToken = cursor.cursorState.postBatchResumeToken;\n  } else {\n    cursor.resumeToken = change._id;\n  }\n\n  // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n  changeStream.options.startAtOperationTime = undefined;\n\n  // Return the change\n  if (eventEmitter) return changeStream.emit('change', change);\n  if (typeof callback === 'function') return callback(error, change);\n  return changeStream.promiseLibrary.resolve(change);\n}\n\n/**\n * The callback format for results\n * @callback ChangeStream~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {(object|null)} result The result object if the command was executed successfully.\n */\n\nmodule.exports = ChangeStream;\n"]},"metadata":{},"sourceType":"script"}